# Family Tree

Реализовать, с учетом ооп подхода, приложение.
Для проведения исследований с генеалогическим древом.

Задание 1: описать некоторое количество компонент, например:
модель человека и дерева.
Под “проведением исследования” можно понимать например получение всех детей выбранного человека.

Задание 2: Дополнить проект методами записи в файл и чтения из файла. Для этого создать отдельный
класс и реализовать в нем нужные методы. Для данного класса сделайте интерфейс, который и используйте в своей программе.

Задание 3: Реализовать интерфейс Iterable для дерева.
Создать методы сортировки списка людей перед выводом, например по имени или по дате рождения. 

Задание 4: Изменить древо, сделать класс параметизированным, чтобы условно дерево можно было использовать не только для людей,
попробовать реализовать класс общения с пользователем, набор команд, для операций над деревом.

Задание 5: Реализовать паттерн MVP в вашем проекте с семейным деревом.

Задание 6: Рефакторинг проекта с семейным деревом с учетом принципов SOLID.

## Принципы SOLID, реализованные в рефакторинге:

### SRP (Принцип единой ответственности):
Model: Human, Gender, Node, IterableInterface, FamilyTree - каждый класс отвечает за одну конкретную сущность (человек, пол, узел дерева, интерфейс итерирования, семейное дерево).
Service: FamilyTreeService - отвечает только за взаимодействие с данными семейного дерева (поиск по имени, получение детей, родителя, братьев/сестер).
Presenter: FamilyTreePresenter - отвечает за логику взаимодействия между моделью и представлением.
View: UserInterface - отвечает за вывод информации пользователю.
Utils: FileHandlerInterface, FileHandler - отвечают только за работу с файлами.

### OCP (принцип открытости / закрытости):
FamilyTreeService, FamilyTreePresenter открыты для расширения, но закрыты для модификации. Можно добавлять новые методы, не меняя существующую логику.
FamilyTree - открыт для расширения, можно добавлять новые методы поиска, фильтрации и сортировки, не трогая существующие методы.

### LSP (принцип подстановки Лискова):
Human реализует интерфейс Node. Можно заменить Human на другой класс, который тоже реализует Node, не нарушая корректность работы.

### ISP (Interface Segregation Principle):
IterableInterface - определяет отдельные методы для сортировки, чтобы не создавать громоздкие интерфейсы.

### DIP (принцип инверсии зависимостей):
FamilyTreeService, FamilyTreePresenter, FamilyTree не зависят от конкретных реализаций, а используют абстракции (Node, IterableInterface, FileHandlerInterface).

Задание 7: Добавить методы: добавление нового человека, установка родственных связей, сохранение и загрузка.